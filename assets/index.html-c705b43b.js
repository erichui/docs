import{_ as a,o as n,c as s,e}from"./app-65bcf5b2.js";const o="/docs/assets/stack-heap-8c167524.png",t={},c=e(`<h1 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h1><p><code>c/c++</code>等系统级语言，需要开发者手动维护内存（<code>rust</code>例外），这非常容易出错。而一些高级语言大多都有自动的垃圾回收机制，如 <code>java/go/javascript</code>。虽然他们有垃圾回收器，但作为开发者的我们还是要了解垃圾回收的工作方式和原理，这有助于帮助我们排查因<strong>内存泄漏</strong>而导致的卡顿，避免此类问题的发生。</p><blockquote><p>这里只介绍浏览器（v8）的垃圾回收</p></blockquote><p>要想弄明白垃圾回收，首先要理解变量的存储方式。</p><h2 id="变量存储方式" tabindex="-1"><a class="header-anchor" href="#变量存储方式" aria-hidden="true">#</a> 变量存储方式</h2><p><code>js</code> 变量分为<strong>原始类型</strong>（值类型）和<strong>引用类型</strong> ，不同类型的变量存储方式不同。其中原始类型存储在栈（<code>stack</code>）中，引用类型存储在堆（<code>heap</code>）中。示例代码在内存中的分布如下图所示：</p><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+'" alt="stack-heap.png"></p><h2 id="栈内存垃圾回收" tabindex="-1"><a class="header-anchor" href="#栈内存垃圾回收" aria-hidden="true">#</a> 栈内存垃圾回收</h2><p><code>js</code> 执行过程中，会将当前上下文压入栈中，当该上下文执行完以后会进行出栈（其实就是指针下移到下面的上下文，当有新的上下文入栈时，会直接覆盖指针以上的空间）。当 <code>fn</code> 执行完以后，原始类型的变量 <code>b</code> 内存被直接释放了，引用类型 <code>obj</code> 的值还存储在 <code>Heap</code>上，销毁的只是对堆内存地址 1011 的引用。</p><h2 id="堆内存垃圾回收" tabindex="-1"><a class="header-anchor" href="#堆内存垃圾回收" aria-hidden="true">#</a> 堆内存垃圾回收</h2><blockquote><p>堆内存垃圾回收基于「代际假说」：大部分新对象的生存</p></blockquote>',12),p=[c];function d(r,i){return n(),s("div",null,p)}const u=a(t,[["render",d],["__file","index.html.vue"]]);export{u as default};
